{"version":3,"sources":["method/memoize.js"],"names":[],"mappings":";;;;;QAQgB,QAAQ,GAAR,QAAQ;;0BARC,eAAe;;AAQjC,SAAS,QAAQ,CAAC,EAAE,EAAE,aAAa,EAAC,GAAG,EAAC;AAC7C,MAAI,IAAI,GAAG,OAAO,CAAC;AACnB,MAAI,IAAI,GAAG,UAAU,CAAC;AACtB,MAAI,QAAQ,YAAA,CAAC;AACb,MAAG,aAAa,CAAC,MAAM,IAAI,CAAC,EAAE,IAAI,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtD,MAAG,aAAa,CAAC,MAAM,IAAI,CAAC,EAAE,IAAI,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;;AAEtD,SAAO,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC;;AAE/C,MAAG,IAAI,KAAK,OAAO,EAAE,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;;AAEpD,WAAS,WAAW,CAAC,CAAC,EAAC;AACrB,KAAC,CAAC,mBAAmB,GAAG,CAAC,CAAC,mBAAmB,IAAI,IAAI,OAAO,EAAE,CAAC;AAC/D,WAAO,CAAC,CAAC,mBAAmB,CAAC;GAC9B;;AAED,SAAO,YAAiB;sCAAL,IAAI;AAAJ,UAAI;;;AAErB,QAAG,IAAI,KAAK,UAAU,EAAE,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;;AAErD,QAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AACvB,QAAG,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,eAAa,MAAM,gBAAa,CAAC;;AAE5D,QAAI,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;;AAGlC,QAAG,CAAC,MAAM,EAAC;AACT,YAAM,GAAG,IAAI,GAAG,EAAE,CAAC;AACnB,cAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;KAC9B;;AAGD,QAAI,IAAI,CAAC;AACT,QAAG,IAAI,KAAK,OAAO,EAAC;AAClB,UAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;KAChC,MAAK,IAAG,IAAI,KAAK,KAAK,EAAC;AACtB,UAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;KAC7B,MAAI;AACH,UAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;KAC/B;AACD,QAAG,CAAC,IAAI,EAAE,IAAI,GAAG,YAAY,CAAC;;AAG9B,QAAI,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;;AAG7B,QAAG,CAAC,KAAK,EAAC;AACR,WAAK,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAClC,YAAM,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;KACzB;;AAED,WAAO,KAAK,CAAC;GACd,CAAA;CACF;;AAEM,IAAI,OAAO,GAAG,YA/Db,UAAU,CA+Dc,SAAS,CAAC,sBAAsB,CAAC,SAAS,EAAC,QAAQ,CAAC,CAAC;QAA1E,OAAO,GAAP,OAAO","file":"method/memoize.js","sourceRoot":"/source/","sourcesContent":["import {Decorators} from '../decorators';\n\n/**\n * Memoize decorator\n * Caches the result of this function and returned the cached value on subsequent calls.\n *\n * @returns {Function}\n */\nexport function _memoize(fn, decoratorArgs,key){\n  let mode = \"first\";\n  let type = \"instance\";\n  let memoized;\n  if(decoratorArgs.length >= 1) mode = decoratorArgs[0];\n  if(decoratorArgs.length >= 2) type = decoratorArgs[1];\n\n  console.log('memoize', fn, decoratorArgs, key);\n\n  if(type === \"class\") memoized = createCache(target);\n\n  function createCache(t){\n    t.__memoizedResults__ = t.__memoizedResults__ || new WeakMap();\n    return t.__memoizedResults__;\n  }\n\n  return function(...args){\n\n    if(type === \"instance\") memoized = createCache(this);\n\n    let mapkey = this[key];\n    if(!mapkey) throw new Error(`property ${mapkey} not found`);\n\n    var values = memoized.get(mapkey);\n\n    //create new weakmap for this method that caches result according to a hashkey derived from the arguments\n    if(!values){\n      values = new Map();\n      memoized.set(mapkey, values);\n    }\n\n    //create a hash based on the arguments passed to the memoized function\n    var hash;\n    if(mode === \"first\"){\n      hash = JSON.stringify(args[0]);\n    }else if(mode === \"all\"){\n      hash = JSON.stringify(args);\n    }else{\n      hash = mode.apply(this, args);\n    }\n    if(!hash) hash = \"__noargs__\";\n\n    //check if current method was already called with these arguments\n    var value = values.get(hash);\n\n    //execute if it wasnt cached already\n    if(!value){\n      value = fn.apply(this, arguments);\n      values.set(hash, value);\n    }\n\n    return value;\n  }\n}\n\nexport var memoize = Decorators.configure.parameterizedDecorator('memoize',_memoize);\n"]}