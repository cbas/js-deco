{"version":3,"sources":["method/memoize.js"],"names":[],"mappings":";;;;;;UAQgB,QAAQ,GAAR,QAAQ;;AAAjB,WAAS,QAAQ,CAAC,EAAE,EAAE,aAAa,EAAC,GAAG,EAAC;AAC7C,QAAI,IAAI,GAAG,OAAO,CAAC;AACnB,QAAI,IAAI,GAAG,UAAU,CAAC;AACtB,QAAI,QAAQ,YAAA,CAAC;AACb,QAAG,aAAa,CAAC,MAAM,IAAI,CAAC,EAAE,IAAI,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtD,QAAG,aAAa,CAAC,MAAM,IAAI,CAAC,EAAE,IAAI,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;;AAEtD,WAAO,CAAC,GAAG,CAAC,SAAS,EAAE,EAAE,EAAE,aAAa,EAAE,GAAG,CAAC,CAAC;;AAE/C,QAAG,IAAI,KAAK,OAAO,EAAE,QAAQ,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;;AAEpD,aAAS,WAAW,CAAC,CAAC,EAAC;AACrB,OAAC,CAAC,mBAAmB,GAAG,CAAC,CAAC,mBAAmB,IAAI,IAAI,OAAO,EAAE,CAAC;AAC/D,aAAO,CAAC,CAAC,mBAAmB,CAAC;KAC9B;;AAED,WAAO,YAAiB;wCAAL,IAAI;AAAJ,YAAI;;;AAErB,UAAG,IAAI,KAAK,UAAU,EAAE,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;;AAErD,UAAI,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;AACvB,UAAG,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,eAAa,MAAM,gBAAa,CAAC;;AAE5D,UAAI,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;;AAGlC,UAAG,CAAC,MAAM,EAAC;AACT,cAAM,GAAG,IAAI,GAAG,EAAE,CAAC;AACnB,gBAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;OAC9B;;AAGD,UAAI,IAAI,CAAC;AACT,UAAG,IAAI,KAAK,OAAO,EAAC;AAClB,YAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;OAChC,MAAK,IAAG,IAAI,KAAK,KAAK,EAAC;AACtB,YAAI,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;OAC7B,MAAI;AACH,YAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;OAC/B;AACD,UAAG,CAAC,IAAI,EAAE,IAAI,GAAG,YAAY,CAAC;;AAG9B,UAAI,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;;AAG7B,UAAG,CAAC,KAAK,EAAC;AACR,aAAK,GAAG,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AAClC,cAAM,CAAC,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;OACzB;;AAED,aAAO,KAAK,CAAC;KACd,CAAA;GACF;;AAEM,MAAI,OAAO,GAAG,YA/Db,UAAU,CA+Dc,SAAS,CAAC,sBAAsB,CAAC,SAAS,EAAC,QAAQ,CAAC,CAAC;UAA1E,OAAO,GAAP,OAAO","file":"method/memoize.js","sourceRoot":"/source/","sourcesContent":["import {Decorators} from '../decorators';\n\n/**\n * Memoize decorator\n * Caches the result of this function and returned the cached value on subsequent calls.\n *\n * @returns {Function}\n */\nexport function _memoize(fn, decoratorArgs,key){\n  let mode = \"first\";\n  let type = \"instance\";\n  let memoized;\n  if(decoratorArgs.length >= 1) mode = decoratorArgs[0];\n  if(decoratorArgs.length >= 2) type = decoratorArgs[1];\n\n  console.log('memoize', fn, decoratorArgs, key);\n\n  if(type === \"class\") memoized = createCache(target);\n\n  function createCache(t){\n    t.__memoizedResults__ = t.__memoizedResults__ || new WeakMap();\n    return t.__memoizedResults__;\n  }\n\n  return function(...args){\n\n    if(type === \"instance\") memoized = createCache(this);\n\n    let mapkey = this[key];\n    if(!mapkey) throw new Error(`property ${mapkey} not found`);\n\n    var values = memoized.get(mapkey);\n\n    //create new weakmap for this method that caches result according to a hashkey derived from the arguments\n    if(!values){\n      values = new Map();\n      memoized.set(mapkey, values);\n    }\n\n    //create a hash based on the arguments passed to the memoized function\n    var hash;\n    if(mode === \"first\"){\n      hash = JSON.stringify(args[0]);\n    }else if(mode === \"all\"){\n      hash = JSON.stringify(args);\n    }else{\n      hash = mode.apply(this, args);\n    }\n    if(!hash) hash = \"__noargs__\";\n\n    //check if current method was already called with these arguments\n    var value = values.get(hash);\n\n    //execute if it wasnt cached already\n    if(!value){\n      value = fn.apply(this, arguments);\n      values.set(hash, value);\n    }\n\n    return value;\n  }\n}\n\nexport var memoize = Decorators.configure.parameterizedDecorator('memoize',_memoize);\n"]}